<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Canon ë ˆì‹œí”¼ & LUT ì œë„¤ë ˆì´í„° (v8.2 ëª¨ë“œ ë°˜ì˜)</title>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0/dist/mobilenet.min.js"></script>

  <style>
    :root{
      --bg:#0f172a; --card:#1e293b; --muted:#94a3b8; --text:#f8fafc;
      --line:#334155; --brand:#ff3f34; --ok:#10b981; --warn:#f59e0b;
      --cyan:#06b6d4; --black:#020617; --radius: 16px;
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    body{ margin:0; font-family: -apple-system, BlinkMacSystemFont, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif; background: var(--bg); color:var(--text); padding: 16px; line-height: 1.5; }
    .app{ max-width: 1000px; margin: 0 auto; padding-bottom: 40px; }

    .header{ display:flex; flex-direction:column; gap:12px; margin-bottom:20px; }
    .title h1{ margin:0; font-size:20px; letter-spacing:-0.5px; }
    .title p{ margin:4px 0 0; color:var(--muted); font-size:13px; word-break: keep-all; }
    .badges{ display:flex; gap:8px; flex-wrap:wrap; }
    .badge{ border:1px solid var(--line); background:rgba(30,41,59,0.7); padding:6px 12px; border-radius:999px; font-size:11px; font-weight:700; display:flex; gap:6px; align-items:center; }
    .dot{ width:8px; height:8px; border-radius:50%; background:var(--muted); }
    .dot.ok{ background:var(--ok); } .dot.warn{ background:var(--warn); }

    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
    @media (max-width: 800px){ .grid{ grid-template-columns:1fr; } }

    .card{ background: var(--card); border:1px solid var(--line); border-radius:var(--radius); box-shadow: 0 4px 6px -1px rgba(0,0,0,0.2); overflow:hidden; }
    .card-h{ padding:16px; display:flex; align-items:center; justify-content:space-between; border-bottom:1px solid var(--line); background: rgba(15,23,42,0.4); }
    .card-h strong{ font-size:15px; }
    .step{ font-size:12px; color:var(--muted); padding:4px 10px; border:1px solid var(--line); border-radius:999px; background:var(--bg); font-weight:700; }
    .card-b{ padding:16px; }

    .uploader{ display:flex; flex-direction:column; gap:12px; }
    .drop{ border:2px dashed var(--line); background: rgba(15,23,42,0.5); border-radius:12px; padding:20px; transition: 0.2s; cursor:pointer; min-height: 140px; display:flex; flex-direction:column; gap:8px; justify-content:center; align-items:center; text-align:center; }
    .drop:active{ background:rgba(255,63,52,0.1); border-color:var(--brand); }
    .drop.dragover{ border-color: var(--ok); background: rgba(16,185,129,0.1); }
    .drop .label{ font-weight:800; font-size:14px; }
    .drop input{ display:none; }
    .thumb{ width:100%; display:none; border-radius:8px; max-height:140px; object-fit:cover; border:1px solid var(--line); }
    .filename{ font-size:12px; color: var(--cyan); font-weight:800; display:none; word-break:break-all; }

    .btn{ border:0; border-radius:12px; padding:16px; font-weight:800; cursor:pointer; transition:0.2s; font-size:14px; width: 100%; display: flex; justify-content: center; align-items: center; gap:8px; }
    .btn.primary{ background: var(--brand); color:white; }
    .btn.primary:active{ filter: brightness(0.9); transform: scale(0.98); }
    .btn.ghost{ background: rgba(30,41,59,0.8); border:1px solid var(--line); color: var(--text); }
    .btn.lut{ background: var(--cyan); color: #000; }
    .btn:disabled{ opacity:0.4; cursor:not-allowed; transform:none !important; }

    .mini{ color:var(--muted); font-size:12px; border:1px solid var(--line); background: var(--bg); padding:12px; border-radius:10px; word-break: keep-all; line-height: 1.5;}

    .seg{ display:flex; flex-direction:column; gap:8px; border:1px solid var(--line); background: var(--bg); padding:12px; border-radius:12px; margin-bottom: 12px;}
    .seg .label{ color:var(--muted); font-size:12px; font-weight:800; }
    .chips{ display:flex; flex-wrap:wrap; gap:6px; }
    .chip{ border:1px solid var(--line); background: var(--card); color: var(--text); padding:10px 14px; border-radius:999px; font-size:13px; font-weight:700; cursor:pointer; transition:0.2s; flex-grow: 1; text-align: center; }
    .chip.active{ border-color: var(--brand); background: rgba(255,63,52,0.15); color: #ff6b6b; }

    .row{ display:flex; gap:10px; flex-wrap:wrap; margin-bottom: 12px;}
    .kv{ flex:1; display:flex; justify-content:space-between; align-items:center; font-size:13px; border:1px solid var(--line); background: var(--bg); padding:10px 14px; border-radius:12px; }
    .kv select{ background: var(--card); border:1px solid var(--line); color:var(--text); border-radius:8px; padding:8px; outline:none; font-weight:600;}

    .tabs{ display:flex; gap:8px; border:1px solid var(--line); background: var(--bg); padding:8px; border-radius:14px; align-items:center; justify-content:space-between; flex-wrap:wrap; margin-top:16px;}
    .tabs .left{ display:flex; gap:8px; flex-wrap:wrap; }
    .tab{ border:1px solid var(--line); background: var(--card); color: var(--text); padding:8px 14px; border-radius:999px; font-size:12px; font-weight:900; cursor:pointer; transition:0.15s; user-select:none; }
    .tab.active{ border-color: var(--ok); box-shadow: 0 0 0 2px rgba(16,185,129,0.15) inset; color: var(--ok);}
    .tabHint{ color:var(--muted); font-size:12px; font-weight:800; padding:6px 10px; border-radius:999px; background: rgba(15,23,42,0.4); white-space:nowrap; }

    .summaryCard{ display:grid; grid-template-columns:1fr; gap:10px; margin-top:12px;}
    .pill{ border:1px solid var(--line); background: var(--bg); border-radius:12px; padding:14px; display:flex; justify-content:space-between; gap:10px; align-items:flex-start;}
    .pill .k{ color:var(--muted); font-size:12px; margin-bottom: 4px;}
    .pill .v{ font-weight:800; font-size: 14px; line-height: 1.4;}
    .pill .v.ok{ color:var(--ok); } .pill .v.warn{ color:var(--warn); } .pill .v.cyan{ color:var(--cyan); }

    .report{ margin-top:12px; background: var(--black); color: var(--ok); border:1px solid rgba(16,185,129,0.3); border-radius:12px; padding:16px; white-space:pre-wrap; font-family: monospace; font-size:13px; overflow-x:auto; line-height:1.6; }

    .spinner{ width:18px; height:18px; border-radius:50%; border:2px solid rgba(255,255,255,0.3); border-top-color: #fff; animation: spin 0.8s linear infinite; display:none; }
    @keyframes spin{ to{ transform: rotate(360deg);} }
    canvas{ display:none; }
  </style>
</head>

<body>
  <div class="app">
    <div class="header">
      <div class="title">
        <h1>ğŸ“· Recipe & 3D LUT ìƒì„±ê¸° <span style="color:var(--cyan); font-size:14px;">v8.2</span></h1>
        <p>ëª¨ë“œ í† ê¸€ì´ â€œì§„ì§œë¡œâ€ ê²°ê³¼ì— ë°˜ì˜ë©ë‹ˆë‹¤. (ì¸ë¬¼=ì•ˆì „, í’ê²½=ê³µê²©, ì•¼ê²½=ì ˆì œ)</p>
      </div>
      <div class="badges">
        <div class="badge"><span id="dotAI" class="dot warn"></span><span id="aiText">AI ë¡œë”©ì¤‘</span></div>
        <div class="badge"><span id="dotOrig" class="dot"></span> ì›ë³¸</div>
        <div class="badge"><span id="dotRef" class="dot"></span> íƒ€ê²Ÿ</div>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <div class="card-h"><strong>STEP 1. ì‚¬ì§„ ì„ íƒ</strong><span class="step">1/3</span></div>
        <div class="card-b">
          <div class="uploader">
            <div class="drop" id="dropOrig">
              <div class="label">1) ì›ë³¸ (Standard í†¤)</div>
              <input id="origFile" type="file" accept="image/*"/>
              <img id="thumbOrig" class="thumb" alt="orig"/>
              <div id="fileOrig" class="filename"></div>
            </div>
            <div class="drop" id="dropRef">
              <div class="label">2) íƒ€ê²Ÿ (ì›í•˜ëŠ” ìƒ‰ê°)</div>
              <input id="refFile" type="file" accept="image/*"/>
              <img id="thumbRef" class="thumb" alt="ref"/>
              <div id="fileRef" class="filename"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-h"><strong>STEP 2. ë¶„ì„ ë° ì¶”ì¶œ</strong><span class="step">2/3</span></div>
        <div class="card-b">
          <div class="seg">
            <div class="label">ëª¨ë“œ ì„ íƒ (í„°ì¹˜)</div>
            <div class="chips">
              <div class="chip active" data-mode="auto" onclick="setMode('auto')">AI ìë™</div>
              <div class="chip" data-mode="portrait" onclick="setMode('portrait')">ì¸ë¬¼</div>
              <div class="chip" data-mode="landscape" onclick="setMode('landscape')">í’ê²½</div>
              <div class="chip" data-mode="snap" onclick="setMode('snap')">ìŠ¤ëƒ…</div>
              <div class="chip" data-mode="night" onclick="setMode('night')">ì•¼ê²½</div>
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>í•´ìƒë„</b>
              <select id="maxDim">
                <option value="1024" selected>1024px</option>
                <option value="1280">1280px</option>
              </select>
            </div>
          </div>

          <button id="btnAnalyze" class="btn primary" onclick="analyzeAll()" disabled>
            âš¡ ë¶„ì„ ì‹œì‘ <span id="spin" class="spinner"></span>
          </button>

          <div class="mini" style="margin-top:12px;">
            <b>ëª¨ë“œ ê°€ì´ë“œ</b><br/>
            â€¢ ì¸ë¬¼: í”¼ë¶€í†¤(R/Y) íŠ€ëŠ” ê±° ì–µì œ (ì•ˆì „)<br/>
            â€¢ í’ê²½: í•˜ëŠ˜/ë…¹ìƒ‰(B/G/C) ë°˜ì˜ ì ê·¹ (ì¨)<br/>
            â€¢ ì•¼ê²½: ê³¼ë„í•œ ìƒ‰ë³€í™˜ ì–µì œ + ì•”ë¶€ ë¦¬í”„íŠ¸ ê°ë„â†‘ (ë²ˆì§ ë°©ì§€)<br/>
            â€¢ ìŠ¤ëƒ…: ì¤‘ë¦½ ë°¸ëŸ°ìŠ¤ (ë¬´ë‚œ)
          </div>
        </div>
      </div>

      <div class="card" style="grid-column: 1 / -1; display:none;" id="resultCard">
        <div class="card-h"><strong>STEP 3. ë¶„ì„ ê²°ê³¼</strong><span class="step" style="color:var(--ok); border-color:var(--ok);">ì™„ë£Œ</span></div>
        <div class="card-b">

          <div style="display:flex; flex-direction:column; gap:10px;">
            <button id="btnLut" class="btn lut" onclick="downloadLUT()">ğŸ¬ 3D LUT (.cube) ë‹¤ìš´ë¡œë“œ</button>
            <div style="display:flex; gap:10px;">
              <button id="btnCopySummary" class="btn ghost" onclick="copySummary()" style="flex:1;">ğŸ“‹ ìš”ì•½ ë³µì‚¬</button>
              <button id="btnCopyFull" class="btn ghost" onclick="copyFull()" style="flex:1;">ğŸ“‹ ì „ì²´ ë³µì‚¬</button>
            </div>
          </div>

          <div class="tabs" id="tabs">
            <div class="left">
              <div class="tab active" data-tab="sum" onclick="setTab('sum')">ìš”ì•½ ë³´ê¸°</div>
              <div class="tab" data-tab="full" onclick="setTab('full')">ì „ì²´ ë³´ê¸°</div>
            </div>
            <div class="tabHint" id="tabHint">ì´ˆë³´ììš© ìš”ì•½ ë·°ì…ë‹ˆë‹¤.</div>
          </div>

          <div class="summaryCard" id="summaryBox">
            <div class="pill">
              <div><div class="k">AI/ëª¨ë“œ íŒë³„</div><div class="v cyan" id="sumAI">-</div></div>
              <div style="text-align:right;"><div class="k">ì¶”ì²œ ë² ì´ìŠ¤</div><div class="v ok" id="sumBase">-</div></div>
            </div>
            <div class="pill">
              <div><div class="k">ëŒ€ë¹„(Contrast)</div><div class="v" id="sumContrast">-</div></div>
              <div style="text-align:right;"><div class="k">ë¸”ë™ ë¦¬í”„íŠ¸</div><div class="v" id="sumLift">-</div></div>
            </div>
            <div class="pill">
              <div><div class="k">í†¤ ì»¤ë¸Œ(Luminance)</div><div class="v" id="sumCurve" style="white-space:pre-wrap; font-size:13px;">-</div></div>
            </div>
            <div class="pill">
              <div><div class="k">6ìƒ‰ì¶•(H/S/L)</div><div class="v" id="sumColors" style="white-space:pre-wrap; font-size:13px;">-</div></div>
            </div>

            <div class="mini">
              <b>ğŸ“· PSE ì…ë ¥ ìˆœì„œ (ìš”ì•½)</b><br/>
              1) Base = <b id="sumBase2">-</b><br/>
              2) Contrast = <b id="sumContrast2">-</b><br/>
              3) Tone Curve = ìœ„ 5ê°œ í¬ì¸íŠ¸ ì…ë ¥<br/>
              4) Specific Colors = 6ìƒ‰ì¶• ìˆ˜ì¹˜ ì…ë ¥
            </div>
          </div>

          <div id="fullBox" style="display:none; margin-top:12px;">
            <div id="reportBox" class="report"></div>
          </div>

          <canvas id="canvas"></canvas>
        </div>
      </div>
    </div>
  </div>

<script>
let origFileState = null, refFileState = null;
let summaryText = "", fullText = "";
let globalToneLUT = null, globalColorSliders = null;

let worker = null, faceModel = null, classifyModel = null, isAiReady = false;
let userMode = "auto", viewTab = "sum";

/* íƒ­ */
function setTab(tab){
  viewTab = tab;
  document.querySelectorAll(".tab").forEach(el=> el.classList.toggle("active", el.dataset.tab === tab));
  const hint = document.getElementById("tabHint");
  if(tab === "sum"){
    hint.textContent = "ì´ˆë³´ììš© ìš”ì•½ ë·°ì…ë‹ˆë‹¤.";
    document.getElementById("summaryBox").style.display = "grid";
    document.getElementById("fullBox").style.display = "none";
  }else{
    hint.textContent = "ìƒì„¸ ë ˆì‹œí”¼ ë¦¬í¬íŠ¸ì…ë‹ˆë‹¤.";
    document.getElementById("summaryBox").style.display = "none";
    document.getElementById("fullBox").style.display = "block";
  }
}

/* ëª¨ë“œ */
function setMode(mode){
  userMode = mode;
  document.querySelectorAll(".chip").forEach(el=> el.classList.toggle("active", el.dataset.mode === mode));
}

/* AI ë¡œë”© */
async function loadAIModels(){
  const dot = document.getElementById('dotAI'), text = document.getElementById('aiText');
  try{
    await tf.ready();
    faceModel = await blazeface.load();
    classifyModel = await mobilenet.load();
    isAiReady = true;
    dot.className = "dot ok"; text.textContent = "AI ì¤€ë¹„ì™„ë£Œ";
  }catch(e){
    isAiReady = true;
    dot.className = "dot warn"; text.textContent = "AI ì‹¤íŒ¨(ìš°íšŒ)";
  }finally{
    refreshReady();
  }
}

/* Ready */
function refreshReady(){
  const hasOrig = !!origFileState, hasRef = !!refFileState;
  document.getElementById('dotOrig').className = "dot " + (hasOrig ? "ok" : "");
  document.getElementById('dotRef').className = "dot " + (hasRef ? "ok" : "");
  document.getElementById('btnAnalyze').disabled = !(hasOrig && hasRef && isAiReady);
}

/* ì—…ë¡œë” */
function setupDropZone(dropId, inputId, thumbId, nameId, onSetFile){
  const drop = document.getElementById(dropId), input = document.getElementById(inputId);
  const thumb = document.getElementById(thumbId), nameEl = document.getElementById(nameId);

  drop.onclick = ()=>input.click();
  drop.ondragover = (e)=>{ e.preventDefault(); drop.classList.add('dragover'); };
  drop.ondragleave = ()=>drop.classList.remove('dragover');
  drop.ondrop = (e)=>{
    e.preventDefault(); drop.classList.remove('dragover');
    const f = e.dataTransfer.files && e.dataTransfer.files[0];
    if(f){ onSetFile(f); updatePreview(f, thumb, nameEl); refreshReady(); }
  };
  input.onchange = ()=>{
    const f = input.files && input.files[0];
    if(f){ onSetFile(f); updatePreview(f, thumb, nameEl); refreshReady(); }
  };
}
function updatePreview(file, imgEl, nameEl){
  nameEl.textContent = "âœ… " + file.name; nameEl.style.display = "block";
  const r = new FileReader();
  r.onload = e=>{ imgEl.src = e.target.result; imgEl.style.display = "block"; };
  r.readAsDataURL(file);
}

/* Worker: v8.2 ëª¨ë“œ ë°˜ì˜ */
function initWorker(){
  if(worker) return;

  const workerCode = `
  function clamp(v,a,b){ return v<a?a:(v>b?b:v); }

  function rgbToHsl(r,g,b){
    const max=Math.max(r,g,b), min=Math.min(r,g,b);
    let h=0, s=0; const l=(max+min)/2;
    if(max!==min){
      const d=max-min;
      s = l>0.5 ? d/(2-max-min) : d/(max+min);
      switch(max){
        case r: h=(g-b)/d+(g<b?6:0); break;
        case g: h=(b-r)/d+2; break;
        case b: h=(r-g)/d+4; break;
      }
      h*=60;
    }
    return [h,s,l];
  }

  function circularHueDiff(h2,h1){
    let d=(h2-h1)%360;
    if(d>180) d-=360;
    if(d<=-180) d+=360;
    return d;
  }

  function luminanceHistFromRGBA(rgba){
    const hist = new Uint32Array(256);
    let total=0, tooDark=0;
    for(let i=0;i<rgba.length;i+=4){
      const lum = (0.299*rgba[i] + 0.587*rgba[i+1] + 0.114*rgba[i+2]) | 0;
      hist[lum]++; total++;
      if(lum<=5) tooDark++;
    }
    return {hist,total,tooDark};
  }

  function cdfFromHist(hist,total){
    const cdf = new Float32Array(256);
    let acc=0;
    for(let i=0;i<256;i++){ acc+=hist[i]; cdf[i]=acc/total; }
    return cdf;
  }

  function percentileByHist(hist,total,p){
    const target=total*p; let acc=0;
    for(let i=0;i<256;i++){ acc+=hist[i]; if(acc>=target) return i; }
    return 255;
  }

  function buildToneLUTByCDFMatch(cdfO,cdfR){
    const lut=new Uint8Array(256);
    let j=0;
    for(let i=0;i<256;i++){
      const p=cdfO[i];
      while(j<255 && cdfR[j]<p) j++;
      lut[i]=j;
    }
    return lut;
  }

  function modePreset(mode, darkRatio){
    // divisors: raw diff -> canon scale, caps: max canon slider
    // liftMul: black-lift sensitivity
    let hueDiv=6.0, satDiv=10.0, lumDiv=10.0;
    let capSkin=6, capOther=8;
    let liftMul=1.0;
    let contrastMul=1.0;

    if(mode==="portrait"){
      hueDiv=6.5; satDiv=11.0; lumDiv=11.0;
      capSkin=5; capOther=7;
      liftMul=1.0;
      contrastMul=0.95;
    }else if(mode==="landscape"){
      hueDiv=5.6; satDiv=9.2; lumDiv=9.2;
      capSkin=6; capOther=8;
      liftMul=0.95;
      contrastMul=1.05;
    }else if(mode==="snap"){
      hueDiv=6.0; satDiv=10.0; lumDiv=10.0;
      capSkin=6; capOther=8;
      liftMul=1.0;
      contrastMul=1.0;
    }else if(mode==="night"){
      hueDiv=7.2; satDiv=12.5; lumDiv=12.5;
      capSkin=4; capOther=5;
      liftMul=1.18;
      contrastMul=0.85;
      if(darkRatio>0.35){
        capSkin=3; capOther=4;
        hueDiv=7.8; satDiv=13.5; lumDiv=13.5;
      }
    }
    return {hueDiv,satDiv,lumDiv,capSkin,capOther,liftMul,contrastMul};
  }

  function applyBlackLiftCompensation(lut, refP02, liftMul){
    const liftRaw = Math.max(0, refP02 - 8);
    const strength = Math.max(0, Math.min(1, (liftRaw/22) * liftMul));
    const liftPx = Math.round(6 + 18*strength);

    const out = new Uint8Array(256);
    for(let i=0;i<256;i++){
      let boost=0;
      if(i<128) boost = liftPx * (1 - (i/128));
      out[i] = Math.min(255, lut[i] + boost);
      if(i>0 && out[i] < out[i-1]) out[i] = out[i-1];
    }
    return {lut: out, isLifted: strength>=0.20, strength, liftPx};
  }

  function getColorAxesDataWeighted(rgba){
    const buckets = {
      R:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
      Y:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
      G:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
      C:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
      B:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
      M:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0}
    };
    let valid=0;
    for(let i=0;i<rgba.length;i+=4){
      let [h,s,l] = rgbToHsl(rgba[i]/255, rgba[i+1]/255, rgba[i+2]/255);
      if(s<0.08 || l<0.06 || l>0.94) continue;

      let k='M';
      if(h>=340 || h<20) k='R';
      else if(h>=20 && h<80) k='Y';
      else if(h>=80 && h<150) k='G';
      else if(h>=150 && h<210) k='C';
      else if(h>=210 && h<280) k='B';

      const w = Math.max(0.01, Math.pow(s,1.5) * (1.0 - Math.min(0.8, Math.abs(l-0.5)*1.6)));
      const rad=h*Math.PI/180, bk=buckets[k];
      bk.sumCos+=Math.cos(rad)*w; bk.sumSin+=Math.sin(rad)*w;
      bk.sumS+=s*w; bk.sumL+=l*w; bk.wSum+=w; bk.count++; valid++;
    }
    const out={};
    for(const k in buckets){
      const b=buckets[k];
      if(b.wSum>0){
        let h=Math.atan2(b.sumSin, b.sumCos)*180/Math.PI;
        if(h<0) h+=360;
        out[k]={H:h, S:b.sumS/b.wSum, L:b.sumL/b.wSum, count:b.count};
      } else out[k]={H:0,S:0,L:0,count:0};
    }
    return {axes: out, validColored: valid};
  }

  function recommendBase(mode, aiType, contrast, cR){
    if(mode && mode!=="auto"){
      if(mode==="portrait") return {base:"ì¸ë¬¼ì‚¬ì§„ (Portrait)", reason:"[ìˆ˜ë™ëª¨ë“œ] ì¸ë¬¼"};
      if(mode==="landscape") return {base:"í’ê²½ì‚¬ì§„ (Landscape)", reason:"[ìˆ˜ë™ëª¨ë“œ] í’ê²½"};
      if(mode==="snap") return {base:"í‘œì¤€ (Standard)", reason:"[ìˆ˜ë™ëª¨ë“œ] ìŠ¤ëƒ…"};
      if(mode==="night") return {base:"ë‰´íŠ¸ëŸ´ (Neutral)", reason:"[ìˆ˜ë™ëª¨ë“œ] ì•¼ê²½(ê³„ì¡° í™•ë³´)"};
    }

    let base="í‘œì¤€ (Standard)", reason="ë²”ìš©ì ì¸ ì„¸íŒ…ì…ë‹ˆë‹¤.";
    if(aiType==="portrait" || (cR.validColored>0 && (cR.axes.R.count + cR.axes.Y.count) > cR.validColored*0.55)){
      base="ì¸ë¬¼ì‚¬ì§„ (Portrait)"; reason="í”¼ë¶€í†¤(R/Y) ì¤‘ì‹¬";
    }else if(aiType==="landscape" || (cR.validColored>0 && (cR.axes.G.count + cR.axes.B.count + cR.axes.C.count) > cR.validColored*0.45)){
      base="í’ê²½ì‚¬ì§„ (Landscape)"; reason="ìì—°(G/B/C) ì¤‘ì‹¬";
    }else if(contrast<=-2){
      base="ë‰´íŠ¸ëŸ´ (Neutral)"; reason="ëŒ€ë¹„ê°€ ë‚®ì•„ ê³„ì¡° í™•ë³´ì— ìœ ë¦¬í•©ë‹ˆë‹¤.";
    }
    return {base, reason};
  }

  self.onmessage = (e)=>{
    const {origRGBA, refRGBA, aiResult, mode} = e.data;

    const o = luminanceHistFromRGBA(origRGBA);
    const r = luminanceHistFromRGBA(refRGBA);
    const darkRatio = r.tooDark / r.total;

    const preset = modePreset(mode || "auto", darkRatio);

    const cdfO = cdfFromHist(o.hist, o.total);
    const cdfR = cdfFromHist(r.hist, r.total);

    const rawLut = buildToneLUTByCDFMatch(cdfO, cdfR);

    const rP02 = percentileByHist(r.hist, r.total, 0.02);
    const liftRes = applyBlackLiftCompensation(rawLut, rP02, preset.liftMul);
    const finalLut = liftRes.lut;

    const oRange = Math.max(1, percentileByHist(o.hist, o.total, 0.95) - percentileByHist(o.hist, o.total, 0.05));
    const rRange = Math.max(1, percentileByHist(r.hist, r.total, 0.95) - percentileByHist(r.hist, r.total, 0.05));
    let contrast = clamp(Math.round((((rRange/oRange)-1)*6) * preset.contrastMul), -4, 4);

    const cO = getColorAxesDataWeighted(origRGBA);
    const cR = getColorAxesDataWeighted(refRGBA);

    const keys = ['R','Y','G','C','B','M'];
    const names = ["Red(ë¹¨ê°•)","Yellow(ë…¸ë‘)","Green(ì´ˆë¡)","Cyan(ì‹œì•ˆ)","Blue(íŒŒë‘)","Magenta(ë§ˆì  íƒ€)"];
    const colorSliders = [];

    for(let i=0;i<6;i++){
      const k = keys[i];
      const countO = cO.axes[k].count;
      const countR = cR.axes[k].count;

      const diffH = (countO>0 && countR>0) ? circularHueDiff(cR.axes[k].H, cO.axes[k].H) : 0;
      const diffS = (countO>0 && countR>0) ? (cR.axes[k].S - cO.axes[k].S) * 100 : 0;
      const diffL = (countO>0 && countR>0) ? (cR.axes[k].L - cO.axes[k].L) * 100 : 0;

      const cap = (k==='R' || k==='Y') ? preset.capSkin : preset.capOther;

      // raw -> canon slider
      const canonH = clamp(Math.round(diffH / preset.hueDiv), -cap, cap);
      const canonS = clamp(Math.round(diffS / preset.satDiv), -cap, cap);
      const canonL = clamp(Math.round(diffL / preset.lumDiv), -cap, cap);

      // LUTìš© raw shiftëŠ” "canon ê°’"ì„ ê¸°ë°˜ìœ¼ë¡œ ì—­ì‚°(ì¼ê´€ì„±)
      // H: deg, S/L: percent
      const rawH = canonH * preset.hueDiv;
      const rawS = canonS * preset.satDiv;
      const rawL = canonL * preset.lumDiv;

      colorSliders.push({
        label: names[i], axis: k,
        H: rawH, S: rawS, L: rawL,
        canonH, canonS, canonL
      });
    }

    const rec = recommendBase(mode || "auto", aiResult.type, contrast, cR);

    self.postMessage({
      ok:true,
      contrast,
      toneLUT: finalLut,
      isLifted: liftRes.isLifted,
      liftStrength: liftRes.strength,
      liftPx: liftRes.liftPx,
      base: rec.base,
      reason: rec.reason,
      colorSliders,
      aiType: aiResult.type
    });
  };
  `;

  const url = URL.createObjectURL(new Blob([workerCode], {type:'application/javascript'}));
  worker = new Worker(url);
  setTimeout(()=>URL.revokeObjectURL(url), 1000);
}

/* ì´ë¯¸ì§€ ì²˜ë¦¬ */
async function decodeToImageBitmap(file){
  const url = URL.createObjectURL(file);
  try{ return await createImageBitmap(file); }
  finally{ URL.revokeObjectURL(url); }
}
function drawScaledToImageData(bitmap, maxDim){
  const scale = Math.min(1, maxDim / Math.max(bitmap.width, bitmap.height));
  const tw = Math.max(1, Math.round(bitmap.width*scale));
  const th = Math.max(1, Math.round(bitmap.height*scale));
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', {willReadFrequently:true});
  canvas.width = tw; canvas.height = th;
  ctx.clearRect(0,0,tw,th);
  ctx.drawImage(bitmap, 0,0,tw,th);
  return ctx.getImageData(0,0,tw,th);
}

/* 3D LUT ìƒì„± */
function generateCubeLUT(toneLUT, sliders){
  const SIZE = 33;
  let content = `TITLE "Canon_Style_LUT_v8_2"\nLUT_3D_SIZE ${SIZE}\n\n`;

  const rgb2hsl = (r,g,b)=>{
    let max=Math.max(r,g,b), min=Math.min(r,g,b);
    let h=0,s=0,l=(max+min)/2;
    if(max!==min){
      let d=max-min;
      s = l>0.5 ? d/(2-max-min) : d/(max+min);
      switch(max){
        case r: h=(g-b)/d+(g<b?6:0); break;
        case g: h=(b-r)/d+2; break;
        case b: h=(r-g)/d+4; break;
      }
      h*=60;
    }
    return [h,s,l];
  };
  const hsl2rgb = (h,s,l)=>{
    const c=(1-Math.abs(2*l-1))*s;
    const x=c*(1-Math.abs((h/60)%2-1));
    const m=l-c/2;
    let r=0,g=0,b=0;
    if(h<60){r=c;g=x;b=0;}
    else if(h<120){r=x;g=c;b=0;}
    else if(h<180){r=0;g=c;b=x;}
    else if(h<240){r=0;g=x;b=c;}
    else if(h<300){r=x;g=0;b=c;}
    else{r=c;g=0;b=x;}
    return [r+m,g+m,b+m];
  };

  for(let bIdx=0; bIdx<SIZE; bIdx++){
    for(let gIdx=0; gIdx<SIZE; gIdx++){
      for(let rIdx=0; rIdx<SIZE; rIdx++){
        let r = Math.round((rIdx/(SIZE-1))*255);
        let g = Math.round((gIdx/(SIZE-1))*255);
        let b = Math.round((bIdx/(SIZE-1))*255);

        r = toneLUT[r]; g = toneLUT[g]; b = toneLUT[b];

        let [hh, ss, ll] = rgb2hsl(r/255, g/255, b/255);

        let axisIdx=-1;
        if(hh>=340 || hh<20) axisIdx=0;
        else if(hh>=20 && hh<80) axisIdx=1;
        else if(hh>=80 && hh<150) axisIdx=2;
        else if(hh>=150 && hh<210) axisIdx=3;
        else if(hh>=210 && hh<280) axisIdx=4;
        else axisIdx=5;

        if(axisIdx!==-1 && ss>0.05){
          const shift = sliders[axisIdx];
          hh = (hh + shift.H) % 360; if(hh<0) hh+=360;
          ss = Math.max(0, Math.min(1, ss + (shift.S/100)));
          ll = Math.max(0, Math.min(1, ll + (shift.L/100)*0.5));
        }

        let [nr, ng, nb] = hsl2rgb(hh, ss, ll);
        content += `${nr.toFixed(6)} ${ng.toFixed(6)} ${nb.toFixed(6)}\n`;
      }
    }
  }
  return content;
}

function downloadLUT(){
  if(!globalToneLUT || !globalColorSliders) return alert("ë¨¼ì € ë¶„ì„ì„ ì§„í–‰í•´ì£¼ì„¸ìš”!");
  const btn = document.getElementById('btnLut');
  btn.textContent = "â³ LUT ìƒì„± ì¤‘...";

  setTimeout(()=>{
    const cubeData = generateCubeLUT(globalToneLUT, globalColorSliders);
    const blob = new Blob([cubeData], {type:'text/plain;charset=utf-8'});
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = `Custom_Recipe_v8_2_${Date.now()}.cube`;
    a.click();

    setTimeout(()=>URL.revokeObjectURL(url), 1000);
    btn.textContent = "ğŸ¬ 3D LUT (.cube) ë‹¤ìš´ë¡œë“œ";
  }, 50);
}

/* ë¶„ì„ ë©”ì¸ */
async function analyzeAll(){
  const btn = document.getElementById('btnAnalyze');
  const spin = document.getElementById('spin');
  btn.disabled = true; spin.style.display = "inline-block";
  document.getElementById('resultCard').style.display = "none";

  try{
    const maxDim = parseInt(document.getElementById('maxDim').value, 10);

    const [bmO, bmR] = await Promise.all([
      decodeToImageBitmap(origFileState),
      decodeToImageBitmap(refFileState)
    ]);

    // NOTE: ë§ˆì§€ë§‰ drawê°€ ìº”ë²„ìŠ¤ì— ë‚¨ìŒ (AIëŠ” ref ê¸°ë°˜ìœ¼ë¡œ íŒë‹¨)
    const idO = drawScaledToImageData(bmO, maxDim);
    const idR = drawScaledToImageData(bmR, maxDim);

    let aiResult = { type:'fallback' };
    if(userMode === "auto" && faceModel && classifyModel){
      const canvas = document.getElementById('canvas');
      const faces = await faceModel.estimateFaces(canvas, false);
      if(faces.length > 0) aiResult = { type:'portrait' };
      else{
        const preds = await classifyModel.classify(canvas);
        const lsKw = ['mountain','ocean','sea','sky','landscape','park','forest','beach','lake','nature'];
        if(preds?.some(p => lsKw.some(kw => p.className.toLowerCase().includes(kw)))) aiResult = { type:'landscape' };
        else aiResult = { type:'standard' };
      }
    } else {
      // ìˆ˜ë™ëª¨ë“œë©´ â€œìˆ˜ë™â€ìœ¼ë¡œ í‘œì‹œë§Œ
      if(userMode !== "auto") aiResult = { type:'manual' };
    }

    const origBuf = idO.data.buffer, refBuf = idR.data.buffer;
    const result = await new Promise((resolve, reject)=>{
      const onMsg = (ev)=>{ cleanup(); resolve(ev.data); };
      const onErr = (err)=>{ cleanup(); reject(err); };
      const cleanup = ()=>{ worker.removeEventListener('message', onMsg); worker.removeEventListener('error', onErr); };
      worker.addEventListener('message', onMsg);
      worker.addEventListener('error', onErr);
      worker.postMessage(
        { origRGBA: new Uint8ClampedArray(origBuf), refRGBA: new Uint8ClampedArray(refBuf), aiResult, mode: userMode },
        [origBuf, refBuf]
      );
    });

    const {contrast, toneLUT, isLifted, base, reason, colorSliders, aiType} = result;
    globalToneLUT = toneLUT;
    globalColorSliders = colorSliders;

    // ìš”ì•½/ì „ì²´ í…ìŠ¤íŠ¸
    const pts = [0,64,128,192,255].map(x => `${x}->${toneLUT[x]}`);
    const cTextInline = pts.join(" | ");
    const colTextInline = colorSliders
      .map(c=> `${c.label.split('(')[0]}: H${c.canonH>0?`+${c.canonH}`:c.canonH} S${c.canonS>0?`+${c.canonS}`:c.canonS} L${c.canonL>0?`+${c.canonL}`:c.canonL}`)
      .join("\n");

    const cTextFull = pts.map(p => {
      const [a,b] = p.split("->");
      return `   â€¢ Point ${a} -> ${b}`;
    }).join("\n");

    const colTextFull = colorSliders.map(c=>
      `[ ${c.label} ]\n  ìƒ‰ì¡°(H): ${c.canonH>0?`+${c.canonH}`:c.canonH} | ì±„ë„(S): ${c.canonS>0?`+${c.canonS}`:c.canonS} | ëª…ë„(L): ${c.canonL>0?`+${c.canonL}`:c.canonL}`
    ).join("\n\n");

    const modeLabel =
      userMode === "auto" ? `AI (${aiType})` :
      `ìˆ˜ë™ (${userMode})`;

    summaryText =
`[Canon Picture Style Recipe - SUMMARY v8.2]
- Mode: ${modeLabel}
1) Base: ${base}
2) Contrast: ${contrast}
3) ToneCurve(5pt): ${cTextInline}
4) SpecificColors(6-axis):
${colTextInline}`.trim();

    fullText =
`==================================================
 ğŸ“· CANON PICTURE STYLE - RECIPE REPORT (v8.2)
==================================================
* ëª¨ë“œ: ${modeLabel}

[ í”½ì³ìŠ¤íƒ€ì¼ ì¶”ì²œ ë² ì´ìŠ¤ ]
â–¶ ê¶Œì¥ ë² ì´ìŠ¤: [ ${base} ]
â–¶ ì¶”ì²œ ì´ìœ : ${reason}

--------------------------------------------------
[1. ê¸°ë³¸ ì„¤ì • (Basic Settings)]
â–¶ ëŒ€ë¹„ (Contrast) : ${contrast}
â–¶ ë¸”ë™ ë¦¬í”„íŠ¸ ê°ì§€: ${isLifted ? "ê°ì§€ë¨ (ì˜í™”ë£©/í•„ë¦„ë£©)" : "ì•½í•¨/ì—†ìŒ"}

--------------------------------------------------
[2. í†¤ ì»¤ë¸Œ ì¢Œí‘œ (Luminance)]
${cTextFull}

--------------------------------------------------
[3. íŠ¹ì • ìƒ‰ìƒ ì¡°ì • (Six Color-Axes)]
${colTextFull}
==================================================`.trim();

    // UI ë°˜ì˜
    document.getElementById('sumAI').textContent = modeLabel;
    document.getElementById('sumBase').textContent = base;
    document.getElementById('sumBase2').textContent = base;

    document.getElementById('sumContrast').textContent = String(contrast);
    document.getElementById('sumContrast2').textContent = String(contrast);

    document.getElementById('sumLift').textContent = isLifted ? "ê°ì§€ë¨ (ì˜í™”ë£©)" : "ì—†ìŒ";
    document.getElementById('sumLift').className = "v " + (isLifted ? "warn" : "ok");

    document.getElementById('sumCurve').textContent = cTextInline.replace(/ \| /g, "\n");
    document.getElementById('sumColors').textContent = colTextInline;

    document.getElementById('reportBox').textContent = fullText;

    document.getElementById('resultCard').style.display = "block";
    setTab("sum");
    document.getElementById('resultCard').scrollIntoView({ behavior:'smooth' });

  }catch(e){
    console.error(e);
    alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.\n(JPG/PNG ê¶Œì¥, HEICëŠ” ë¸Œë¼ìš°ì €ì— ë”°ë¼ ì‹¤íŒ¨í•  ìˆ˜ ìˆì–´ìš”)");
  }finally{
    btn.disabled = false;
    spin.style.display = "none";
    refreshReady();
  }
}

/* ë³µì‚¬ */
async function copySummary(){
  if(!summaryText) return;
  try{ await navigator.clipboard.writeText(summaryText); alert("ìš”ì•½ì„ ë³µì‚¬í–ˆìŠµë‹ˆë‹¤!"); }
  catch(e){ const ta=document.createElement('textarea'); ta.value=summaryText; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta); alert("ìš”ì•½ì„ ë³µì‚¬í–ˆìŠµë‹ˆë‹¤!"); }
}
async function copyFull(){
  if(!fullText) return;
  try{ await navigator.clipboard.writeText(fullText); alert("ì „ì²´ ë ˆì‹œí”¼ë¥¼ ë³µì‚¬í–ˆìŠµë‹ˆë‹¤!"); }
  catch(e){ const ta=document.createElement('textarea'); ta.value=fullText; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta); alert("ì „ì²´ ë ˆì‹œí”¼ë¥¼ ë³µì‚¬í–ˆìŠµë‹ˆë‹¤!"); }
}

/* init */
window.onload = ()=>{
  setupDropZone('dropOrig','origFile','thumbOrig','fileOrig', f=>origFileState=f);
  setupDropZone('dropRef','refFile','thumbRef','fileRef', f=>refFileState=f);
  initWorker();
  loadAIModels();
  setTab('sum');
};
</script>
</body>
</html>